<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="title">TRON æ™ºèƒ½åˆçº¦äº¤äº’å·¥å…·</title>
    <link
        href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Noto+Sans+SC:wght@400;500;600;700&display=swap"
        rel="stylesheet">
    <!-- 
        TRON åˆçº¦äº¤äº’æ–¹æ¡ˆ:
        - Read å‡½æ•°: ä½¿ç”¨ TronGrid HTTP API (æ— éœ€ TronWeb)
        - Write å‡½æ•°: ä½¿ç”¨ TronLink æ³¨å…¥çš„ tronWeb (éœ€è¦é’±åŒ…ç­¾å)
    -->
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --bg-card: #1c2128;
            --border-color: #30363d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --accent-red: #ff4d4f;
            --accent-green: #3fb950;
            --accent-blue: #58a6ff;
            --accent-purple: #bc8cff;
            --accent-orange: #d29922;
            --accent-cyan: #39c5cf;
            --gradient-start: #ff4d4f;
            --gradient-end: #d29922;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans SC', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
        }

        /* èƒŒæ™¯è£…é¥° */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 400px;
            background:
                radial-gradient(ellipse 80% 50% at 50% -20%, rgba(255, 77, 79, 0.15), transparent),
                radial-gradient(ellipse 60% 40% at 80% 10%, rgba(210, 153, 34, 0.1), transparent);
            pointer-events: none;
            z-index: -1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 24px;
        }

        /* å¤´éƒ¨ */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 32px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 48px;
            height: 48px;
            background: var(--accent-blue);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: 700;
            color: white;
            box-shadow: 0 4px 20px rgba(88, 166, 255, 0.3);
        }

        .logo h1 {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .wallet-status {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .network-badge {
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .network-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-orange);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .connect-btn {
            padding: 10px 24px;
            background: var(--accent-blue);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .connect-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(255, 77, 79, 0.4);
        }

        .connect-btn.connected {
            background: var(--bg-tertiary);
            border: 1px solid var(--accent-green);
            color: var(--accent-green);
        }

        .address-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--accent-cyan);
        }

        /* ä¸»å¸ƒå±€ */
        .main-grid {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 24px;
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        /* å¡ç‰‡æ ·å¼ */
        .card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            overflow: hidden;
        }

        .card-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .card-title {
            font-size: 1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card-title-icon {
            width: 28px;
            height: 28px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .card-body {
            padding: 20px;
        }

        /* è¡¨å•æ§ä»¶ */
        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .form-input {
            width: 100%;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 0.9rem;
            font-family: 'JetBrains Mono', monospace;
            transition: all 0.2s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(88, 166, 255, 0.15);
        }

        .form-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.6;
        }

        textarea.form-input {
            min-height: 200px;
            resize: vertical;
            font-size: 0.8rem;
        }

        select.form-input {
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%238b949e' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 36px;
        }

        /* æŒ‰é’® */
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary {
            background: var(--accent-blue);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(88, 166, 255, 0.3);
        }

        .btn-success {
            background: var(--accent-green);
            color: var(--bg-primary);
        }

        .btn-danger {
            background: var(--accent-red);
            color: white;
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .btn-block {
            width: 100%;
        }

        /* å‡½æ•°åˆ—è¡¨ */
        /* å‡½æ•°åˆ—è¡¨ */
        .functions-container {
            height: auto;
            overflow: visible;
        }

        .functions-container::-webkit-scrollbar {
            width: 6px;
        }

        .functions-container::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        .functions-container::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        .function-tabs {
            display: flex;
            gap: 8px;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-secondary);
        }

        .function-tab {
            padding: 8px 20px;
            background: transparent;
            border: 1px solid transparent;
            border-radius: 8px;
            color: var(--text-secondary);
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .function-tab:hover {
            color: var(--text-primary);
            background: var(--bg-tertiary);
        }

        .function-tab.active {
            background: var(--bg-tertiary);
            border-color: var(--border-color);
            color: var(--text-primary);
        }

        .function-tab .count {
            margin-left: 6px;
            padding: 2px 8px;
            background: var(--bg-primary);
            border-radius: 10px;
            font-size: 0.75rem;
        }

        .function-list {
            padding: 16px;
        }

        .function-item {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            margin-bottom: 12px;
            overflow: hidden;
            transition: all 0.2s ease;
        }

        .function-item:hover {
            border-color: var(--accent-blue);
        }

        .function-item.expanded {
            border-color: var(--accent-blue);
            box-shadow: 0 4px 20px rgba(88, 166, 255, 0.1);
        }

        .function-header {
            padding: 14px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
        }

        .function-name {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .function-type-badge {
            padding: 3px 10px;
            border-radius: 6px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .function-type-badge.read {
            background: rgba(63, 185, 80, 0.15);
            color: var(--accent-green);
        }

        .function-type-badge.write {
            background: rgba(255, 77, 79, 0.15);
            color: var(--accent-red);
        }

        .function-toggle {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            transition: transform 0.2s ease;
        }

        .function-item.expanded .function-toggle {
            transform: rotate(180deg);
        }

        .function-body {
            padding: 0 16px 16px;
            display: none;
            border-top: 1px solid var(--border-color);
            margin-top: 0;
            padding-top: 16px;
        }

        .function-item.expanded .function-body {
            display: block;
        }

        .param-input {
            margin-bottom: 12px;
        }

        .param-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
            margin-bottom: 6px;
        }

        .param-name {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent-cyan);
        }

        .param-type {
            color: var(--text-secondary);
            font-size: 0.75rem;
        }

        .param-field {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.85rem;
            font-family: 'JetBrains Mono', monospace;
        }

        .param-field:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .function-actions {
            display: flex;
            gap: 12px;
            margin-top: 16px;
        }

        .function-actions .btn {
            flex: 1;
            padding: 10px 16px;
            font-size: 0.85rem;
        }

        /* ç»“æœæ˜¾ç¤º */
        .result-container {
            margin-top: 16px;
            padding: 14px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
        }

        .result-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .result-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            word-break: break-all;
            white-space: pre-wrap;
            color: var(--accent-green);
        }

        .result-value.error {
            color: var(--accent-red);
        }

        .result-value.pending {
            color: var(--accent-orange);
        }

        /* æ—¥å¿—é¢æ¿ */
        .logs-panel {
            margin-top: 24px;
        }

        .logs-content {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 16px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
        }

        .log-entry {
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 12px;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-time {
            color: var(--text-secondary);
            flex-shrink: 0;
        }

        .log-message {
            flex: 1;
            word-break: break-all;
        }

        .log-message.success {
            color: var(--accent-green);
        }

        .log-message.error {
            color: var(--accent-red);
        }

        .log-message.info {
            color: var(--accent-blue);
        }

        /* ç©ºçŠ¶æ€ */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .empty-state-text {
            font-size: 0.95rem;
        }

        /* åŠ è½½åŠ¨ç”» */
        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Toastæç¤º */
        .toast-container {
            position: fixed;
            top: 24px;
            right: 24px;
            z-index: 1000;
        }

        .toast {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 14px 20px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 12px;
            animation: slideIn 0.3s ease;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .toast.success {
            border-left: 3px solid var(--accent-green);
        }

        .toast.error {
            border-left: 3px solid var(--accent-red);
        }

        .toast.info {
            border-left: 3px solid var(--accent-blue);
        }

        /* å“åº”å¼ */
        @media (max-width: 768px) {
            .container {
                padding: 16px;
            }

            header {
                flex-direction: column;
                gap: 16px;
            }

            .wallet-status {
                width: 100%;
                flex-direction: column;
            }

            .connect-btn {
                width: 100%;
            }
        }

        /* Language Switcher */
        .language-switcher {
            display: flex;
            gap: 8px;
        }

        .lang-btn {
            padding: 6px 12px;
            background: transparent;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .lang-btn:hover {
            color: var(--text-primary);
            border-color: var(--text-secondary);
        }

        .lang-btn.active {
            background: var(--bg-tertiary);
            color: var(--accent-blue);
            border-color: var(--accent-blue);
        }
    </style>
</head>

<body>
    <div class="toast-container" id="toastContainer"></div>

    <div class="container">
        <header>
            <div class="logo">
                <div class="logo-icon">T</div>
                <h1 data-i18n="header_title">TRON æ™ºèƒ½åˆçº¦äº¤äº’å·¥å…·</h1>
            </div>
            <div style="display: flex; align-items: center; gap: 16px; flex-wrap: wrap; justify-content: flex-end;">
                <div class="language-switcher">
                    <button class="lang-btn active" onclick="setLanguage('zh')" id="langBtn_zh">ä¸­æ–‡</button>
                    <button class="lang-btn" onclick="setLanguage('en')" id="langBtn_en">EN</button>
                </div>
                <div class="wallet-status">
                    <div class="network-badge" id="networkBadge">
                        <span class="network-dot"></span>
                        <span id="networkName" data-i18n="wallet_not_connected">æœªè¿æ¥</span>
                    </div>
                    <button class="connect-btn" id="connectBtn" onclick="connectWallet()" data-i18n="connect_wallet">
                        ğŸ”— è¿æ¥ TronLink
                    </button>
                </div>
            </div>
        </header>

        <div class="main-grid">
            <!-- å·¦ä¾§é…ç½®é¢æ¿ -->
            <div class="config-panel">
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">
                            <span class="card-title-icon">âš™ï¸</span>
                            <span data-i18n="config_title">åˆçº¦é…ç½®</span>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="form-group">
                            <label class="form-label" data-i18n="network_label">ç½‘ç»œé€‰æ‹©</label>
                            <select class="form-input" id="networkSelect" onchange="switchNetwork()">
                                <option value="mainnet" data-i18n="network_mainnet">ä¸»ç½‘ (Mainnet)</option>
                                <option value="shasta" selected data-i18n="network_shasta">Shasta æµ‹è¯•ç½‘</option>
                                <option value="nile" data-i18n="network_nile">Nile æµ‹è¯•ç½‘</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label class="form-label" data-i18n="contract_address_label">åˆçº¦åœ°å€</label>
                            <input type="text" class="form-input" id="contractAddress" placeholder="T... æ ¼å¼çš„åˆçº¦åœ°å€"
                                data-i18n-placeholder="contract_address_placeholder">
                        </div>
                        <div class="form-group">
                            <label class="form-label" data-i18n="abi_label">åˆçº¦ ABI (JSON æ ¼å¼)</label>
                            <textarea class="form-input" id="contractAbi" placeholder='ç²˜è´´åˆçº¦ ABI JSON...'
                                data-i18n-placeholder="abi_placeholder"></textarea>
                        </div>
                        <button class="btn btn-primary btn-block" onclick="loadContract()"
                            data-i18n="load_contract_btn">
                            ğŸ“„ åŠ è½½åˆçº¦
                        </button>
                    </div>
                </div>

                <!-- æ—¥å¿—é¢æ¿ -->
                <div class="card logs-panel">
                    <div class="card-header">
                        <div class="card-title">
                            <span class="card-title-icon">ğŸ“‹</span>
                            <span data-i18n="logs_title">æ“ä½œæ—¥å¿—</span>
                        </div>
                        <button class="btn btn-secondary" onclick="clearLogs()"
                            style="padding: 6px 12px; font-size: 0.8rem;" data-i18n="clear_logs_btn">
                            æ¸…ç©º
                        </button>
                    </div>
                    <div class="card-body">
                        <div class="logs-content" id="logsContent">
                            <div class="log-entry">
                                <span class="log-time">--:--:--</span>
                                <span class="log-message info" data-i18n="logs_waiting">ç­‰å¾…æ“ä½œ...</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- å³ä¾§å‡½æ•°é¢æ¿ -->
            <div class="card functions-panel">
                <div class="card-header">
                    <div class="card-title">
                        <span class="card-title-icon">ğŸ”§</span>
                        <span data-i18n="functions_title">åˆçº¦å‡½æ•°</span>
                    </div>
                    <span id="walletAddress" class="address-display"></span>
                </div>
                <div class="function-tabs">
                    <button class="function-tab active" data-type="all" onclick="filterFunctions('all')">
                        <span data-i18n="tab_all">å…¨éƒ¨</span> <span class="count" id="countAll">0</span>
                    </button>
                    <button class="function-tab" data-type="read" onclick="filterFunctions('read')">
                        <span data-i18n="tab_read">ğŸ“– Read</span> <span class="count" id="countRead">0</span>
                    </button>
                    <button class="function-tab" data-type="write" onclick="filterFunctions('write')">
                        <span data-i18n="tab_write">âœï¸ Write</span> <span class="count" id="countWrite">0</span>
                    </button>
                </div>
                <div class="functions-container">
                    <div class="function-list" id="functionList">
                        <div class="empty-state">
                            <div class="empty-state-icon">ğŸ“œ</div>
                            <div class="empty-state-text" data-i18n="empty_abi">è¯·å…ˆåŠ è½½åˆçº¦ ABI</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let tronWebWallet = null;  // TronLink é’±åŒ…çš„ TronWeb å®ä¾‹ (ç”± TronLink æ³¨å…¥)
        let currentAbi = null;
        let currentFilter = 'all';
        let currentLang = localStorage.getItem('tron_contract_lang') || 'zh';

        // ç¿»è¯‘æ•°æ®
        const translations = {
            zh: {
                title: "TRON æ™ºèƒ½åˆçº¦äº¤äº’å·¥å…·",
                header_title: "TRON æ™ºèƒ½åˆçº¦äº¤äº’å·¥å…·",
                connect_wallet: "ğŸ”— è¿æ¥ TronLink",
                wallet_connected: "å·²è¿æ¥",
                wallet_not_connected: "æœªè¿æ¥",
                wallet_readonly: "åªè¯»",
                config_title: "åˆçº¦é…ç½®",
                network_label: "ç½‘ç»œé€‰æ‹©",
                network_mainnet: "ä¸»ç½‘ (Mainnet)",
                network_shasta: "Shasta æµ‹è¯•ç½‘",
                network_nile: "Nile æµ‹è¯•ç½‘",
                contract_address_label: "åˆçº¦åœ°å€",
                contract_address_placeholder: "T... æ ¼å¼çš„åˆçº¦åœ°å€",
                abi_label: "åˆçº¦ ABI (JSON æ ¼å¼)",
                abi_placeholder: "ç²˜è´´åˆçº¦ ABI JSON...",
                load_contract_btn: "ğŸ“„ åŠ è½½åˆçº¦",
                logs_title: "æ“ä½œæ—¥å¿—",
                clear_logs_btn: "æ¸…ç©º",
                logs_waiting: "ç­‰å¾…æ“ä½œ...",
                functions_title: "åˆçº¦å‡½æ•°",
                tab_all: "å…¨éƒ¨",
                tab_read: "ğŸ“– Read",
                tab_write: "âœï¸ Write",
                empty_abi: "è¯·å…ˆåŠ è½½åˆçº¦ ABI",
                empty_functions: "æœªæ‰¾åˆ°å¯è°ƒç”¨çš„å‡½æ•°",
                no_params: "æ— è¾“å…¥å‚æ•°",
                btn_read: "ğŸ“– æŸ¥è¯¢",
                btn_write: "âœï¸ å‘é€äº¤æ˜“",
                result_label: "æ‰§è¡Œç»“æœ",
                querying: "æŸ¥è¯¢ä¸­...",
                waiting_signature: "ç­‰å¾… TronLink ç­¾åç¡®è®¤...",
                tx_sent: "äº¤æ˜“å·²å‘é€!",
                tx_id: "TxID:",
                input_placeholder: "è¾“å…¥ {type} ç±»å‹çš„å€¼",
                // Messages
                msg_config_node: "å·²é…ç½® {name} èŠ‚ç‚¹ (HTTP API æ¨¡å¼)",
                msg_page_loaded: "é¡µé¢åŠ è½½å®Œæˆï¼ŒRead åŠŸèƒ½å¯ç”¨ (ä½¿ç”¨ HTTP API)",
                msg_tronlink_connected: "TronLink å·²è¿æ¥: {address}",
                msg_tronlink_installed: "TronLink å·²å®‰è£…ï¼Œç‚¹å‡»\"è¿æ¥ TronLink\"æŒ‰é’®æˆæƒ",
                msg_unlock_wallet: "è¯·å…ˆåœ¨ TronLink ä¸­è§£é”é’±åŒ…",
                msg_no_tronlink: "æœªæ£€æµ‹åˆ° TronLinkï¼ŒRead åŠŸèƒ½å¯ç”¨ï¼ŒWrite éœ€è¦å®‰è£… TronLink",
                msg_install_tronlink: "è¯·å…ˆå®‰è£… TronLink æµè§ˆå™¨æ‰©å±•",
                msg_requesting_auth: "æ­£åœ¨è¯·æ±‚ TronLink æˆæƒ...",
                msg_wallet_connected: "é’±åŒ…è¿æ¥æˆåŠŸ",
                msg_auth_queued: "æˆæƒè¯·æ±‚å·²åœ¨é˜Ÿåˆ—ä¸­ï¼Œè¯·åœ¨ TronLink ä¸­ç¡®è®¤",
                msg_auth_refused: "ç”¨æˆ·æ‹’ç»æˆæƒ",
                msg_auth_failed: "æˆæƒå¤±è´¥",
                msg_wallet_connected_auth: "é’±åŒ…å·²è¿æ¥ (å·²æˆæƒ)",
                msg_connect_failed: "è¿æ¥å¤±è´¥: {error}",
                msg_switch_network: "è¯·åœ¨ TronLink ä¸­åˆ‡æ¢åˆ° {network}",
                msg_switch_network_hint: "æç¤º: è¯·åœ¨ TronLink é’±åŒ…ä¸­æ‰‹åŠ¨åˆ‡æ¢åˆ° {network}",
                msg_switched_readonly: "å·²åˆ‡æ¢åˆ° {network} (åªè¯»æ¨¡å¼)",
                msg_enter_address: "è¯·è¾“å…¥åˆçº¦åœ°å€",
                msg_enter_abi: "è¯·è¾“å…¥åˆçº¦ ABI",
                msg_abi_error: "ABI JSON æ ¼å¼é”™è¯¯",
                msg_contract_loaded: "åˆçº¦åŠ è½½æˆåŠŸ: {address}",
                msg_load_failed: "åŠ è½½å¤±è´¥: {error}",
                msg_func_not_found: "å‡½æ•°æœªæ‰¾åˆ°",
                msg_call_read: "è°ƒç”¨ {func}()...",
                msg_return: "{func}() è¿”å›: {result}",
                msg_error: "{func}() é”™è¯¯: {error}",
                msg_call_write: "å‘é€äº¤æ˜“ {func}()ï¼Œç­‰å¾…ç­¾å...",
                msg_tx_success: "äº¤æ˜“å‘é€æˆåŠŸ: {txId}",
                msg_tx_failed: "äº¤æ˜“å¤±è´¥: {error}",
                msg_logs_cleared: "æ—¥å¿—å·²æ¸…ç©º",
                msg_requesting_switch: "æ­£åœ¨è¯·æ±‚åˆ‡æ¢åˆ° {network}...",
                msg_switch_success: "å·²æˆåŠŸåˆ‡æ¢åˆ° {network}",
                msg_switch_cancelled: "ç”¨æˆ·å–æ¶ˆäº†ç½‘ç»œåˆ‡æ¢"
            },
            en: {
                title: "TRON Contract Caller",
                header_title: "TRON Contract Caller",
                connect_wallet: "ğŸ”— Connect TronLink",
                wallet_connected: "Connected",
                wallet_not_connected: "Not Connected",
                wallet_readonly: "Read-Only",
                config_title: "Contract Config",
                network_label: "Network",
                network_mainnet: "Mainnet",
                network_shasta: "Shasta Testnet",
                network_nile: "Nile Testnet",
                contract_address_label: "Contract Address",
                contract_address_placeholder: "Contract Address (starts with T...)",
                abi_label: "Contract ABI (JSON)",
                abi_placeholder: "Paste Contract ABI JSON here...",
                load_contract_btn: "ğŸ“„ Load Contract",
                logs_title: "Operation Logs",
                clear_logs_btn: "Clear",
                logs_waiting: "Waiting for operations...",
                functions_title: "Functions",
                tab_all: "All",
                tab_read: "ğŸ“– Read",
                tab_write: "âœï¸ Write",
                empty_abi: "Please load contract ABI first",
                empty_functions: "No callable functions found",
                no_params: "No input parameters",
                btn_read: "ğŸ“– Query",
                btn_write: "âœï¸ Send",
                result_label: "Result",
                querying: "Querying...",
                waiting_signature: "Waiting for TronLink signature...",
                tx_sent: "Transaction Sent!",
                tx_id: "TxID:",
                input_placeholder: "Enter value for {type}",
                // Messages
                msg_config_node: "Configured {name} node (HTTP API mode)",
                msg_page_loaded: "Page loaded, Read functions available (HTTP API)",
                msg_tronlink_connected: "TronLink Connected: {address}",
                msg_tronlink_installed: "TronLink installed, click 'Connect TronLink' to authorize",
                msg_unlock_wallet: "Please unlock wallet in TronLink",
                msg_no_tronlink: "TronLink not detected. Read available, Write requires TronLink",
                msg_install_tronlink: "Please install TronLink extension",
                msg_requesting_auth: "Requesting TronLink authorization...",
                msg_wallet_connected: "Wallet Connected",
                msg_auth_queued: "Authorization request queued, please confirm in TronLink",
                msg_auth_refused: "User refused authorization",
                msg_auth_failed: "Authorization failed",
                msg_wallet_connected_auth: "Wallet Connected (Authorized)",
                msg_connect_failed: "Connection failed: {error}",
                msg_switch_network: "Please switch to {network} in TronLink",
                msg_switch_network_hint: "Hint: Please manually switch to {network} in TronLink wallet",
                msg_switched_readonly: "Switched to {network} (Read-Only)",
                msg_enter_address: "Please enter contract address",
                msg_enter_abi: "Please enter contract ABI",
                msg_abi_error: "Invalid ABI JSON format",
                msg_contract_loaded: "Contract loaded: {address}",
                msg_load_failed: "Load failed: {error}",
                msg_func_not_found: "Function not found",
                msg_call_read: "Calling {func}()...",
                msg_return: "{func}() returned: {result}",
                msg_error: "{func}() error: {error}",
                msg_call_write: "Sending transaction {func}(), waiting for signature...",
                msg_tx_success: "Transaction sent: {txId}",
                msg_tx_failed: "Transaction failed: {error}",
                msg_logs_cleared: "Logs cleared",
                msg_requesting_switch: "Requesting to switch to {network}...",
                msg_switch_success: "Successfully switched to {network}",
                msg_switch_cancelled: "Network switch cancelled by user"
            }
        };

        // è·å–ç¿»è¯‘
        function t(key, params = {}) {
            let text = translations[currentLang][key] || key;
            for (const [k, v] of Object.entries(params)) {
                text = text.replace(`{${k}}`, v);
            }
            return text;
        }

        // åˆ‡æ¢è¯­è¨€
        function setLanguage(lang) {
            currentLang = lang;
            localStorage.setItem('tron_contract_lang', lang);
            updateLanguage();
        }

        // æ›´æ–°ç•Œé¢è¯­è¨€
        function updateLanguage() {
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.toggle('active', btn.id === `langBtn_${currentLang}`);
            });

            // æ›´æ–°é™æ€æ–‡æœ¬
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (translations[currentLang][key]) {
                    el.textContent = translations[currentLang][key];
                }
            });

            // æ›´æ–° Placeholder
            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.getAttribute('data-i18n-placeholder');
                if (translations[currentLang][key]) {
                    el.placeholder = translations[currentLang][key];
                }
            });

            // æ›´æ–°æ ‡é¢˜
            document.title = t('title');
            document.documentElement.lang = currentLang === 'zh' ? 'zh-CN' : 'en';

            // æ›´æ–°ç½‘ç»œé€‰æ‹©æ¡†
            const networkSelect = document.getElementById('networkSelect');
            if (networkSelect) {
                Array.from(networkSelect.options).forEach(opt => {
                    if (opt.value === 'mainnet') opt.text = t('network_mainnet');
                    if (opt.value === 'shasta') opt.text = t('network_shasta');
                    if (opt.value === 'nile') opt.text = t('network_nile');
                });
            }

            // æ›´æ–°åŠ¨æ€å†…å®¹
            updateWalletStatus();
            if (currentAbi) {
                renderFunctions(currentAbi);
            }
        }

        // ç½‘ç»œé…ç½®

        // ç½‘ç»œé…ç½®
        const networks = {
            mainnet: {
                name: 'ä¸»ç½‘',
                fullHost: 'https://api.trongrid.io',
                explorer: 'https://tronscan.org',
                chainId: '0x2b6653dc'
            },
            shasta: {
                name: 'Shasta æµ‹è¯•ç½‘',
                fullHost: 'https://api.shasta.trongrid.io',
                explorer: 'https://shasta.tronscan.org',
                chainId: '0x94a9059e'
            },
            nile: {
                name: 'Nile æµ‹è¯•ç½‘',
                fullHost: 'https://nile.trongrid.io',
                explorer: 'https://nile.tronscan.org',
                chainId: '0xcd8690dc'
            }
        };

        // è·å–å½“å‰ç½‘ç»œé…ç½®
        function getCurrentNetwork() {
            const network = document.getElementById('networkSelect').value;
            return networks[network];
        }

        // åœ°å€è½¬æ¢å·¥å…·
        const addressUtils = {
            // Base58 åœ°å€è½¬ Hex (å»æ‰Tå‰ç¼€ï¼Œè½¬æ¢ä¸º41å¼€å¤´)
            toHex: function (base58Address) {
                if (!base58Address || base58Address.length !== 34) return null;
                // ç®€åŒ–ç‰ˆï¼šä½¿ç”¨ TronLink çš„ tronWeb è½¬æ¢ï¼Œæˆ–ä½¿ç”¨çº¯ JS å®ç°
                if (window.tronWeb && window.tronWeb.address) {
                    return window.tronWeb.address.toHex(base58Address);
                }
                // å¤‡ç”¨ï¼šå¦‚æœåœ°å€ä»¥41å¼€å¤´ï¼Œç›´æ¥è¿”å›
                if (base58Address.startsWith('41')) {
                    return base58Address;
                }
                return null;
            },

            // Base58 è§£ç  (æ­£ç¡®å®ç°)
            decodeBase58: function (str) {
                const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

                // ä½¿ç”¨ BigInt å¤„ç†å¤§æ•°
                let n = BigInt(0);
                for (let i = 0; i < str.length; i++) {
                    const idx = ALPHABET.indexOf(str[i]);
                    if (idx < 0) return null;
                    n = n * BigInt(58) + BigInt(idx);
                }

                // è½¬æ¢ä¸ºå­—èŠ‚æ•°ç»„
                let hex = n.toString(16);
                if (hex.length % 2) hex = '0' + hex;

                const bytes = [];
                for (let i = 0; i < hex.length; i += 2) {
                    bytes.push(parseInt(hex.substring(i, i + 2), 16));
                }

                // å¤„ç†å‰å¯¼ '1' (Base58 çš„é›¶)
                for (let i = 0; i < str.length && str[i] === '1'; i++) {
                    bytes.unshift(0);
                }

                return bytes;
            },

            // Base58 è½¬ Hex åœ°å€ (æ­£ç¡®å®ç°)
            base58ToHex: function (base58) {
                try {
                    if (!base58 || !base58.startsWith('T')) return null;

                    const decoded = this.decodeBase58(base58);
                    if (!decoded || decoded.length < 25) return null;

                    // å»æ‰æœ€å 4 å­—èŠ‚æ ¡éªŒå’Œï¼Œå–å‰ 21 å­—èŠ‚
                    const addressBytes = decoded.slice(0, 21);
                    return addressBytes.map(b => ('0' + b.toString(16)).slice(-2)).join('');
                } catch (e) {
                    console.error('Base58 decode error:', e);
                    return null;
                }
            },

            // è·å–åœ°å€å‚æ•° (ç”¨äºåˆçº¦è°ƒç”¨ï¼Œå»æ‰ 41 å‰ç¼€å¹¶å¡«å……åˆ° 64 ä½)
            getAddressParameter: function (address) {
                if (address.startsWith('T')) {
                    const hex = this.base58ToHex(address);
                    if (hex && hex.startsWith('41')) {
                        return hex.substring(2).padStart(64, '0');
                    }
                }
                // å¦‚æœå·²ç»æ˜¯ hex æ ¼å¼
                if (address.startsWith('41')) {
                    return address.substring(2).padStart(64, '0');
                }
                if (address.startsWith('0x')) {
                    return address.substring(2).padStart(64, '0');
                }
                return address.padStart(64, '0');
            }
        };

        // ABI ç¼–ç å·¥å…·
        const abiEncoder = {
            // ç¼–ç å‡½æ•°é€‰æ‹©å™¨
            encodeFunctionSelector: function (funcName, inputTypes) {
                const signature = funcName + '(' + inputTypes.join(',') + ')';
                return this.keccak256(signature).substring(0, 8);
            },

            // ç®€åŒ–ç‰ˆ keccak256 (ä½¿ç”¨å†…ç½®æˆ–å¤–éƒ¨åº“)
            keccak256: function (str) {
                // å¦‚æœ TronLink å¯ç”¨ï¼Œä½¿ç”¨å®ƒçš„ sha3
                if (window.tronWeb && window.tronWeb.sha3) {
                    const hash = window.tronWeb.sha3(str, false);
                    return hash.replace('0x', '');
                }
                // å¦åˆ™ä½¿ç”¨ç®€åŒ–çš„å“ˆå¸Œ (æ³¨æ„ï¼šè¿™ä¸æ˜¯çœŸæ­£çš„ keccak256)
                // å®é™…åº”ç”¨ä¸­åº”è¯¥ä½¿ç”¨æ­£ç¡®çš„å“ˆå¸Œåº“
                console.warn('Using fallback hash - may not work correctly');
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = ((hash << 5) - hash) + str.charCodeAt(i);
                    hash |= 0;
                }
                return Math.abs(hash).toString(16).padStart(8, '0');
            },

            // ç¼–ç å‚æ•°
            encodeParameter: function (type, value) {
                if (type === 'address') {
                    let hex = value;
                    if (value.startsWith('T')) {
                        hex = addressUtils.base58ToHex(value) || value;
                    }
                    // åœ°å€å¡«å……åˆ°32å­—èŠ‚
                    return hex.replace('0x', '').replace('41', '').padStart(64, '0');
                }
                if (type.startsWith('uint') || type.startsWith('int')) {
                    const num = BigInt(value);
                    return num.toString(16).padStart(64, '0');
                }
                if (type === 'bool') {
                    return (value === true || value === 'true' ? '1' : '0').padStart(64, '0');
                }
                if (type === 'bytes32') {
                    return value.replace('0x', '').padStart(64, '0');
                }
                // å…¶ä»–ç±»å‹...
                return value.toString(16).padStart(64, '0');
            },

            // ç¼–ç å®Œæ•´çš„å‡½æ•°è°ƒç”¨æ•°æ®
            encodeFunction: function (funcName, inputs, values) {
                const types = inputs.map(i => i.type);
                const selector = this.encodeFunctionSelector(funcName, types);

                let data = selector;
                for (let i = 0; i < inputs.length; i++) {
                    data += this.encodeParameter(inputs[i].type, values[i]);
                }
                return data;
            },

            // è§£ç è¿”å›å€¼
            decodeOutput: function (hexData, outputs) {
                if (!hexData || hexData === '0x' || !outputs || outputs.length === 0) {
                    return null;
                }

                const data = hexData.replace('0x', '');
                const results = [];
                let offset = 0;

                for (const output of outputs) {
                    const chunk = data.substring(offset, offset + 64);
                    offset += 64;

                    if (output.type.startsWith('uint') || output.type.startsWith('int')) {
                        results.push(BigInt('0x' + chunk).toString());
                    } else if (output.type === 'bool') {
                        results.push(parseInt(chunk, 16) !== 0);
                    } else if (output.type === 'address') {
                        results.push('41' + chunk.substring(24));
                    } else if (output.type === 'bytes32') {
                        results.push('0x' + chunk);
                    } else if (output.type === 'string') {
                        // å­—ç¬¦ä¸²æ˜¯åŠ¨æ€ç±»å‹ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†
                        const strOffset = parseInt(chunk, 16) * 2;
                        const strLength = parseInt(data.substring(strOffset, strOffset + 64), 16);
                        const strData = data.substring(strOffset + 64, strOffset + 64 + strLength * 2);
                        let str = '';
                        for (let i = 0; i < strData.length; i += 2) {
                            str += String.fromCharCode(parseInt(strData.substring(i, i + 2), 16));
                        }
                        results.push(str);
                    } else {
                        results.push('0x' + chunk);
                    }
                }

                return results.length === 1 ? results[0] : results;
            }
        };

        // åˆå§‹åŒ–åªè¯»æ¨¡å¼
        function createReadOnlyTronWeb() {
            const config = getCurrentNetwork();
            log(t('msg_config_node', { name: config.name }), 'info');
            return true;
        }

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            // åˆå§‹åŒ–ç½‘ç»œé…ç½®
            createReadOnlyTronWeb();
            // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
            updateWalletStatus();
            // æ£€æµ‹ TronLink (æ ¹æ®å®˜æ–¹æ–‡æ¡£ä½¿ç”¨è½®è¯¢æ–¹å¼)
            checkTronLink();
            // åŠ è½½ä¿å­˜çš„é…ç½®
            loadSavedConfig();
            // åˆå§‹åŒ–è¯­è¨€
            updateLanguage();

            log(t('msg_page_loaded'), 'info');
        });

        // æ£€æŸ¥ TronLink - æ ¹æ®å®˜æ–¹æ–‡æ¡£ https://developers.tron.network/docs/tronlink-integration
        function checkTronLink() {
            // ä½¿ç”¨å®˜æ–¹æ¨èçš„è½®è¯¢æ–¹å¼æ£€æµ‹ TronLink
            const checkInterval = setInterval(() => {
                // å®˜æ–¹æ¨èçš„æ£€æµ‹æ–¹å¼
                if (window.tronWeb && window.tronWeb.defaultAddress.base58) {
                    clearInterval(checkInterval);

                    tronWebWallet = window.tronWeb;
                    log(t('msg_tronlink_connected', { address: window.tronWeb.defaultAddress.base58 }), 'success');
                    updateWalletStatus();

                    // ç›‘å¬ TronLink äº‹ä»¶
                    window.addEventListener('message', (e) => {
                        if (e.data && e.data.message) {
                            const action = e.data.message.action;
                            if (action === 'accountsChanged' ||
                                action === 'setAccount' ||
                                action === 'setNode' ||
                                action === 'connect' ||
                                action === 'disconnect') {
                                console.log('TronLink äº‹ä»¶:', action);
                                updateWalletStatus();
                            }
                        }
                    });

                } else if (window.tronLink) {
                    // TronLink å·²å®‰è£…ä½†æœªæˆæƒ
                    clearInterval(checkInterval);
                    log(t('msg_tronlink_installed'), 'info');

                    if (window.tronLink.ready === false) {
                        log(t('msg_unlock_wallet'), 'info');
                    }
                }
            }, 100); // å®˜æ–¹ç¤ºä¾‹ä½¿ç”¨ 10msï¼Œè¿™é‡Œç”¨ 100ms æ›´åˆç†

            // 5ç§’ååœæ­¢æ£€æµ‹
            setTimeout(() => {
                clearInterval(checkInterval);
                if (!window.tronLink && !window.tronWeb) {
                    log(t('msg_no_tronlink'), 'info');
                }
            }, 5000);
        }

        // è¿æ¥é’±åŒ… - æ ¹æ®å®˜æ–¹æ–‡æ¡£ https://developers.tron.network/docs/tronlink-integration
        async function connectWallet() {
            try {
                // æ£€æŸ¥ TronLink æ˜¯å¦å®‰è£…
                if (!window.tronLink && !window.tronWeb) {
                    showToast(t('msg_install_tronlink'), 'error');
                    window.open('https://www.tronlink.org/', '_blank');
                    return;
                }

                log(t('msg_requesting_auth'), 'info');

                // å®˜æ–¹æ¨èæ–¹å¼: ä½¿ç”¨ tronLink.request
                if (window.tronLink && window.tronLink.request) {
                    const res = await window.tronLink.request({ method: 'tron_requestAccounts' });

                    // æ ¹æ®å®˜æ–¹æ–‡æ¡£å¤„ç†è¿”å›ç 
                    // code: 200 - ç”¨æˆ·æ¥å—æˆæƒ
                    // code: 4000 - åœ¨é˜Ÿåˆ—ä¸­ï¼Œæ— éœ€é‡å¤æäº¤
                    // code: 4001 - ç”¨æˆ·æ‹’ç»æˆæƒ

                    if (res.code === 200) {
                        tronWebWallet = window.tronWeb;
                        updateWalletStatus();
                        log(t('msg_wallet_connected'), 'success');
                        showToast(t('msg_wallet_connected'), 'success');
                        return;
                    } else if (res.code === 4000) {
                        log(t('msg_auth_queued'), 'info');
                        showToast(t('msg_auth_queued'), 'info');
                        return;
                    } else if (res.code === 4001) {
                        throw new Error(t('msg_auth_refused'));
                    } else {
                        throw new Error(res.message || t('msg_auth_failed'));
                    }
                }

                // å¤‡ç”¨æ–¹å¼: ç›´æ¥æ£€æŸ¥ window.tronWeb (å¯èƒ½å·²ç»æˆæƒ)
                if (window.tronWeb && window.tronWeb.defaultAddress && window.tronWeb.defaultAddress.base58) {
                    tronWebWallet = window.tronWeb;
                    updateWalletStatus();
                    log(t('msg_wallet_connected_auth'), 'success');
                    showToast(t('msg_wallet_connected_auth'), 'success');
                    return;
                }

                throw new Error(t('msg_unlock_wallet'));

            } catch (error) {
                log(t('msg_connect_failed', { error: error.message }), 'error');
                showToast(t('msg_connect_failed', { error: error.message }), 'error');
            }
        }

        // æ›´æ–°é’±åŒ…çŠ¶æ€
        function updateWalletStatus() {
            const connectBtn = document.getElementById('connectBtn');
            const walletAddress = document.getElementById('walletAddress');
            const networkBadge = document.getElementById('networkBadge');
            const networkName = document.getElementById('networkName');

            if (window.tronWeb && window.tronWeb.defaultAddress && window.tronWeb.defaultAddress.base58) {
                tronWebWallet = window.tronWeb;
                const address = tronWebWallet.defaultAddress.base58;
                const shortAddress = `${address.slice(0, 6)}...${address.slice(-4)}`;

                connectBtn.textContent = shortAddress;
                connectBtn.classList.add('connected');
                walletAddress.textContent = address;

                // æ£€æµ‹å½“å‰ç½‘ç»œ
                const fullNode = tronWebWallet.fullNode?.host || '';
                let detectedNetwork = 'unknown';

                if (fullNode.includes('nile')) {
                    detectedNetwork = 'nile';
                } else if (fullNode.includes('shasta')) {
                    detectedNetwork = 'shasta';
                } else if (fullNode.includes('trongrid.io') || fullNode.includes('tronstack')) {
                    detectedNetwork = 'mainnet';
                }

                if (networks[detectedNetwork]) {
                    networkName.textContent = networks[detectedNetwork].name + ' (' + t('wallet_connected') + ')';
                    document.getElementById('networkSelect').value = detectedNetwork;
                    // åŒæ­¥æ›´æ–°åªè¯»å®ä¾‹
                    createReadOnlyTronWeb();
                } else {
                    networkName.textContent = t('wallet_connected');
                }
            } else {
                connectBtn.innerHTML = t('connect_wallet');
                connectBtn.classList.remove('connected');
                walletAddress.textContent = '';
                const network = document.getElementById('networkSelect').value;
                networkName.textContent = networks[network].name + ' (' + t('wallet_readonly') + ')';
            }
        }

        // åˆ‡æ¢ç½‘ç»œ
        async function switchNetwork() {
            const networkKey = document.getElementById('networkSelect').value;
            const targetNetwork = networks[networkKey];

            // æ›´æ–°åªè¯» TronWeb å®ä¾‹
            createReadOnlyTronWeb();

            // æ£€æŸ¥å½“å‰è¿æ¥çš„é’±åŒ…ç½‘ç»œ
            if (tronWebWallet && window.tronWeb && window.tronWeb.fullNode && window.tronWeb.fullNode.host) {
                const currentHost = window.tronWeb.fullNode.host;
                let currentNetworkKey = 'unknown';

                if (currentHost.includes('nile')) currentNetworkKey = 'nile';
                else if (currentHost.includes('shasta')) currentNetworkKey = 'shasta';
                else if (currentHost.includes('trongrid.io') || currentHost.includes('tronstack')) currentNetworkKey = 'mainnet';

                if (currentNetworkKey !== networkKey) {
                    // TronLink ä¸æ”¯æŒé€šè¿‡ API åˆ‡æ¢ TRON ç½‘ç»œ (ä»…æ”¯æŒ EVM ç½‘ç»œåˆ‡æ¢)
                    // æ‰€ä»¥æˆ‘ä»¬éœ€è¦æç¤ºç”¨æˆ·æ‰‹åŠ¨åˆ‡æ¢
                    console.log('Network mismatch. Target:', networkKey, 'Current:', currentNetworkKey);
                    showToast(t('msg_switch_network_hint', { network: targetNetwork.name }), 'info');
                    log(t('msg_switch_network_hint', { network: targetNetwork.name }), 'info');
                } else {
                    log(t('msg_switched_readonly', { network: targetNetwork.name }), 'success');
                }
            } else {
                showToast(t('msg_switched_readonly', { network: targetNetwork.name }), 'info');
            }

            // updateWalletStatus ä¼šåœ¨ç”¨æˆ·å®é™…åˆ‡æ¢ç½‘ç»œåé€šè¿‡ setNode äº‹ä»¶è§¦å‘
            // è¿™é‡Œæˆ‘ä»¬åªæ›´æ–°åªè¯»çŠ¶æ€ï¼Œä¸å¼ºåˆ¶åˆ·æ–°é’±åŒ…çŠ¶æ€ï¼Œä»¥å…è¦†ç›–ç”¨æˆ·çš„é€‰æ‹©
        }

        // åŠ è½½åˆçº¦
        function loadContract() {
            try {
                const address = document.getElementById('contractAddress').value.trim();
                const abiJson = document.getElementById('contractAbi').value.trim();

                if (!address) {
                    throw new Error(t('msg_enter_address'));
                }

                if (!abiJson) {
                    throw new Error(t('msg_enter_abi'));
                }

                // è§£æ ABI
                let abi;
                try {
                    abi = JSON.parse(abiJson);
                } catch (e) {
                    throw new Error(t('msg_abi_error'));
                }

                currentAbi = abi;
                saveConfig(address, abiJson);
                renderFunctions(abi);

                log(t('msg_contract_loaded', { address: address }), 'success');
                showToast(t('msg_contract_loaded', { address: address }), 'success');
            } catch (error) {
                log(t('msg_load_failed', { error: error.message }), 'error');
                showToast(error.message, 'error');
            }
        }

        // æ¸²æŸ“å‡½æ•°åˆ—è¡¨
        function renderFunctions(abi) {
            const functionList = document.getElementById('functionList');
            const functions = abi.filter(item => item.type === 'function');

            // åˆ†ç±»ç»Ÿè®¡
            const readFunctions = functions.filter(f => isReadFunction(f));
            const writeFunctions = functions.filter(f => !isReadFunction(f));

            document.getElementById('countAll').textContent = functions.length;
            document.getElementById('countRead').textContent = readFunctions.length;
            document.getElementById('countWrite').textContent = writeFunctions.length;

            if (functions.length === 0) {
                functionList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">âš ï¸</div>
                        <div class="empty-state-text" data-i18n="empty_functions">${t('empty_functions')}</div>
                    </div>
                `;
                return;
            }

            // æŒ‰ç±»å‹æ’åºï¼Œreadåœ¨å‰
            const sortedFunctions = [...readFunctions, ...writeFunctions];

            functionList.innerHTML = sortedFunctions.map((func, index) => {
                const isRead = isReadFunction(func);
                const funcType = isRead ? 'read' : 'write';
                const inputs = func.inputs || [];

                return `
                    <div class="function-item" data-type="${funcType}" data-index="${index}">
                        <div class="function-header" onclick="toggleFunction(${index})">
                            <span class="function-name">
                                <span class="function-type-badge ${funcType}">${funcType}</span>
                                ${func.name}
                            </span>
                            <span class="function-toggle">â–¼</span>
                        </div>
                        <div class="function-body">
                            ${inputs.length > 0 ? inputs.map((input, i) => `
                                <div class="param-input">
                                    <label class="param-label">
                                        <span class="param-name">${input.name || `param${i}`}</span>
                                        <span class="param-type">(${input.type})</span>
                                    </label>
                                    <input type="text" class="param-field" 
                                        id="param_${index}_${i}" 
                                        placeholder="${t('input_placeholder', { type: input.type })}"
                                        data-type="${input.type}">
                                </div>
                            `).join('') : `<p style="color: var(--text-secondary); font-size: 0.85rem;" data-i18n="no_params">${t('no_params')}</p>`}
                            
                            <div class="function-actions">
                                ${isRead ? `
                                    <button class="btn btn-success" onclick="callReadFunction('${func.name}', ${index})">
                                        <span data-i18n="btn_read">${t('btn_read')}</span>
                                    </button>
                                ` : `
                                    <button class="btn btn-danger" onclick="callWriteFunction('${func.name}', ${index})">
                                        <span data-i18n="btn_write">${t('btn_write')}</span>
                                    </button>
                                `}
                            </div>
                            
                            <div class="result-container" id="result_${index}" style="display: none;">
                                <div class="result-label" data-i18n="result_label">${t('result_label')}</div>
                                <div class="result-value" id="resultValue_${index}"></div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            filterFunctions(currentFilter);
        }

        // åˆ¤æ–­æ˜¯å¦ä¸ºè¯»å‡½æ•°
        function isReadFunction(func) {
            const state = func.stateMutability?.toLowerCase();
            return state === 'view' || state === 'pure' || func.constant === true;
        }

        // åˆ‡æ¢å‡½æ•°å±•å¼€/æŠ˜å 
        function toggleFunction(index) {
            const item = document.querySelector(`.function-item[data-index="${index}"]`);
            item.classList.toggle('expanded');
        }

        // è¿‡æ»¤å‡½æ•°
        function filterFunctions(type) {
            currentFilter = type;
            const tabs = document.querySelectorAll('.function-tab');
            tabs.forEach(tab => {
                tab.classList.toggle('active', tab.dataset.type === type);
            });

            const items = document.querySelectorAll('.function-item');
            items.forEach(item => {
                if (type === 'all' || item.dataset.type === type) {
                    item.style.display = 'block';
                } else {
                    item.style.display = 'none';
                }
            });
        }

        // è·å–å‡½æ•°å‚æ•°
        // è·å–æ’åºåçš„å‡½æ•°åˆ—è¡¨ (ä¸æ¸²æŸ“é¡ºåºä¸€è‡´)
        function getSortedFunctions() {
            const functions = currentAbi.filter(item => item.type === 'function');
            const readFunctions = functions.filter(f => isReadFunction(f));
            const writeFunctions = functions.filter(f => !isReadFunction(f));
            return [...readFunctions, ...writeFunctions];
        }

        function getParams(funcName, funcIndex) {
            // ä½¿ç”¨æ’åºåçš„å‡½æ•°åˆ—è¡¨ (ä¸æ¸²æŸ“é¡ºåºä¸€è‡´)
            const sortedFuncs = getSortedFunctions();
            const func = sortedFuncs[funcIndex];

            if (!func) {
                console.error('Function not found at index:', funcIndex);
                return [];
            }

            const inputs = func.inputs || [];
            const params = [];

            for (let i = 0; i < inputs.length; i++) {
                const input = document.getElementById(`param_${funcIndex}_${i}`);
                if (!input) {
                    console.error(`Input element not found: param_${funcIndex}_${i}`);
                    params.push('');
                    continue;
                }
                let value = input.value.trim();

                // ç±»å‹è½¬æ¢
                const type = inputs[i].type;
                if (type.includes('int') && !type.includes('[]')) {
                    value = value;  // ä¿æŒå­—ç¬¦ä¸²ï¼ŒTronWebä¼šå¤„ç†
                } else if (type === 'bool') {
                    value = value.toLowerCase() === 'true';
                } else if (type.includes('[]')) {
                    try {
                        value = JSON.parse(value);
                    } catch (e) {
                        value = value.split(',').map(v => v.trim());
                    }
                }

                params.push(value);
            }

            return params;
        }

        // è°ƒç”¨è¯»å‡½æ•° - ä½¿ç”¨ HTTP APIï¼Œä¸éœ€è¦é’±åŒ…
        async function callReadFunction(funcName, funcIndex) {
            const resultContainer = document.getElementById(`result_${funcIndex}`);
            const resultValue = document.getElementById(`resultValue_${funcIndex}`);

            try {
                const address = document.getElementById('contractAddress').value.trim();
                if (!address) {
                    throw new Error(t('msg_enter_address'));
                }

                resultContainer.style.display = 'block';
                resultValue.className = 'result-value pending';
                resultValue.textContent = t('querying');

                log(t('msg_call_read', { func: funcName }), 'info');

                // è·å–å‡½æ•°ä¿¡æ¯ (ä½¿ç”¨æ’åºåçš„åˆ—è¡¨)
                const sortedFuncs = getSortedFunctions();
                const func = sortedFuncs[funcIndex];

                if (!func) {
                    throw new Error(t('msg_func_not_found'));
                }

                // è·å–å‚æ•°
                const params = getParams(funcName, funcIndex);

                // æ–¹å¼1: å¦‚æœ TronLink å¯ç”¨ï¼Œä¼˜å…ˆä½¿ç”¨ TronLink çš„ tronWeb
                if (window.tronWeb && window.tronWeb.contract) {
                    try {
                        const contractInstance = await window.tronWeb.contract(currentAbi, address);
                        let result;
                        if (params.length > 0) {
                            result = await contractInstance[funcName](...params).call();
                        } else {
                            result = await contractInstance[funcName]().call();
                        }

                        // æ ¼å¼åŒ–ç»“æœ
                        const displayResult = formatResult(result);
                        resultValue.className = 'result-value';
                        resultValue.textContent = displayResult;
                        log(t('msg_return', { func: funcName, result: displayResult }), 'success');
                        return;
                    } catch (e) {
                        console.log('TronLink call failed, trying HTTP API:', e.message);
                    }
                }

                // æ–¹å¼2: ä½¿ç”¨ TronGrid HTTP API (ä¸éœ€è¦ TronLink)
                const config = getCurrentNetwork();

                // æ„å»ºå‡½æ•°é€‰æ‹©å™¨
                const inputTypes = (func.inputs || []).map(i => i.type);
                const functionSelector = funcName + '(' + inputTypes.join(',') + ')';

                // æ„å»ºå‚æ•° (ç¼–ç ä¸º hex)
                let parameter = '';
                for (let i = 0; i < (func.inputs || []).length; i++) {
                    const paramValue = params[i];
                    const paramType = func.inputs[i].type;

                    if (paramType === 'address') {
                        // ä½¿ç”¨æ–°çš„åœ°å€å‚æ•°ç¼–ç æ–¹æ³•
                        parameter += addressUtils.getAddressParameter(paramValue);
                    } else {
                        parameter += abiEncoder.encodeParameter(paramType, paramValue);
                    }
                }

                log(`HTTP API è¯·æ±‚: ${functionSelector}`, 'info');

                // è°ƒç”¨ TronGrid API - ä½¿ç”¨ visible: true æ”¯æŒ Base58 åœ°å€
                const response = await fetch(`${config.fullHost}/wallet/triggerconstantcontract`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        owner_address: address, // ä½¿ç”¨åŸå§‹ Base58 åœ°å€
                        contract_address: address,
                        function_selector: functionSelector,
                        parameter: parameter,
                        visible: true // ä½¿ç”¨ visible: true æ”¯æŒ Base58 åœ°å€
                    })
                });

                const data = await response.json();

                if (data.result && data.result.result === false) {
                    throw new Error(data.result.message || t('msg_load_failed', { error: 'Unknown error' }));
                }

                if (!data.constant_result || data.constant_result.length === 0) {
                    throw new Error(t('msg_load_failed', { error: 'No return value' }));
                }

                // è§£ç è¿”å›å€¼
                const hexResult = data.constant_result[0];
                const decodedResult = abiEncoder.decodeOutput(hexResult, func.outputs || []);

                const displayResult = typeof decodedResult === 'object'
                    ? JSON.stringify(decodedResult, null, 2)
                    : String(decodedResult);

                resultValue.className = 'result-value';
                resultValue.textContent = displayResult;
                log(t('msg_return', { func: funcName, result: displayResult }), 'success');

            } catch (error) {
                resultValue.className = 'result-value error';
                resultValue.textContent = error.message;
                log(t('msg_error', { func: funcName, error: error.message }), 'error');
            }
        }

        // æ ¼å¼åŒ–ç»“æœ
        function formatResult(result) {
            if (typeof result === 'object') {
                if (result._isBigNumber || (result.toString && typeof result.toNumber === 'function')) {
                    return result.toString();
                } else {
                    return JSON.stringify(result, (key, value) => {
                        if (typeof value === 'bigint') {
                            return value.toString();
                        }
                        if (value && value._isBigNumber) {
                            return value.toString();
                        }
                        return value;
                    }, 2);
                }
            }
            return String(result);
        }

        // è°ƒç”¨å†™å‡½æ•° - éœ€è¦é’±åŒ…ç­¾å
        async function callWriteFunction(funcName, funcIndex) {
            const resultContainer = document.getElementById(`result_${funcIndex}`);
            const resultValue = document.getElementById(`resultValue_${funcIndex}`);

            try {
                // æ£€æŸ¥é’±åŒ…è¿æ¥ - ä½¿ç”¨ window.tronWeb (ç”± TronLink æ³¨å…¥)
                const tw = window.tronWeb;
                if (!tw || !tw.defaultAddress || !tw.defaultAddress.base58) {
                    throw new Error(t('msg_unlock_wallet'));
                }

                const address = document.getElementById('contractAddress').value.trim();
                if (!address) {
                    throw new Error(t('msg_enter_address'));
                }

                resultContainer.style.display = 'block';
                resultValue.className = 'result-value pending';
                resultValue.textContent = t('waiting_signature');

                log(t('msg_call_write', { func: funcName }), 'info');

                // ä½¿ç”¨ TronLink æ³¨å…¥çš„ tronWeb åˆ›å»ºåˆçº¦å®ä¾‹
                const contractInstance = await tw.contract(currentAbi, address);

                // è·å–å‚æ•°
                const params = getParams(funcName, funcIndex);

                // è°ƒç”¨å‡½æ•° (ä¼šè§¦å‘ TronLink ç­¾åå¼¹çª—)
                let txId;
                if (params.length > 0) {
                    txId = await contractInstance[funcName](...params).send({
                        feeLimit: 100_000_000,  // 100 TRX
                        callValue: 0
                    });
                } else {
                    txId = await contractInstance[funcName]().send({
                        feeLimit: 100_000_000,
                        callValue: 0
                    });
                }

                // è·å–å½“å‰ç½‘ç»œçš„æµè§ˆå™¨
                const network = document.getElementById('networkSelect').value;
                const explorer = networks[network].explorer;

                resultValue.className = 'result-value';
                resultValue.innerHTML = `
                    ${t('tx_sent')}<br>
                    ${t('tx_id')} <a href="${explorer}/#/transaction/${txId}" target="_blank" style="color: var(--accent-blue);">${txId}</a>
                `;

                log(t('msg_tx_success', { txId: txId }), 'success');
                showToast(t('msg_tx_success', { txId: txId }), 'success');

            } catch (error) {
                resultValue.className = 'result-value error';
                resultValue.textContent = error.message || t('msg_tx_failed', { error: 'Unknown' });
                log(t('msg_error', { func: funcName, error: error.message }), 'error');
                showToast(t('msg_tx_failed', { error: error.message }), 'error');
            }
        }

        // æ—¥å¿—åŠŸèƒ½
        function log(message, type = 'info') {
            const logsContent = document.getElementById('logsContent');
            const time = new Date().toLocaleTimeString('zh-CN', { hour12: false });

            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `
                <span class="log-time">${time}</span>
                <span class="log-message ${type}">${message}</span>
            `;

            logsContent.insertBefore(entry, logsContent.firstChild);

            // é™åˆ¶æ—¥å¿—æ•°é‡
            while (logsContent.children.length > 50) {
                logsContent.removeChild(logsContent.lastChild);
            }
        }

        function clearLogs() {
            const logsContent = document.getElementById('logsContent');
            logsContent.innerHTML = `
                <div class="log-entry">
                    <span class="log-time">--:--:--</span>
                    <span class="log-message info" data-i18n="msg_logs_cleared">${t('msg_logs_cleared')}</span>
                </div>
            `;
        }

        // Toast æç¤º
        function showToast(message, type = 'info') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <span>${type === 'success' ? 'âœ…' : type === 'error' ? 'âŒ' : 'â„¹ï¸'}</span>
                <span>${message}</span>
            `;
            container.appendChild(toast);

            setTimeout(() => {
                toast.style.animation = 'slideIn 0.3s ease reverse';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // æœ¬åœ°å­˜å‚¨
        function saveConfig(address, abi) {
            localStorage.setItem('tron_contract_address', address);
            localStorage.setItem('tron_contract_abi', abi);
        }

        function loadSavedConfig() {
            const address = localStorage.getItem('tron_contract_address');
            const abi = localStorage.getItem('tron_contract_abi');

            if (address) {
                document.getElementById('contractAddress').value = address;
            }
            if (abi) {
                document.getElementById('contractAbi').value = abi;
            }
        }
    </script>
</body>

</html>